\section{Eliminating the parsing step}
Many of the works on prettyprinting that have been published ---
such as the well-known one by Derek C. Oppen \autocite{prettyprinting} ---
propose algorithms that place line breaks into a stream of tokens.
Such a stream could be generated by a lexer;
a parser would only be required to obtain a tree structure according to
the syntactic grammar of the language.
But for any conventional formatting algorithm,
by the time it comes to actually applying the algorithm to a specific language,
parsing the tokens becomes necessary.
This is because it is sometimes hard and often impossible to
recognize coherent blocks in the token stream,
deduct the meaning of each token without knowledge about its greater surroundings or
retrieve any other information that could be used for
determining suitable spacing or line break positions when
going left to right over code written in any practical language.

An example of this problem arises with the ambigious meaning of the
\code{-} (minus) symbol \autocite[Chapter: Introduction]{prettyGoodFormattingPipeline},
which many languages use both as a
unary operator that computes the additive inverse of its operand and as a
binary operator that subtracts its right-hand operand from its left-hand operand.
Consider the following use of the `minus' symbol with its immediate neighbor tokens:
\begin{minted}{text}
  ), -, x
\end{minted}
One might intuitively proclaim that this minus symbol has to be a binary operator,
subtracting the value stored as identifier \code{x} from
whatever subexpression the parenthesis on the left closes.
But the syntactic grammars of most languages are not that simple;
the whole statement could be
\begin{minted}{c}
  if (a == b) -x;
\end{minted}
, or the language might allow parenthesized type casts and the statement looks like this:
\begin{minted}{c}
  int y = (int) -x;
\end{minted}

There are good reasons to parse the source code in order to
get better insight into its structure before attempting to prettyprint it,
but what if we still try to create a formatter that actually omits that parsing step,
printing out nicely formatted source code just based on the tokens recognized by the lexer?

\subsection{Potential benefits}
\subsection{Drawbacks}

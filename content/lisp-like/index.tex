\chapter{Lisp-like syntax}
To gain insight on how a non-parsing formatter could be built,
let us first take a look at a small language with Lisp-like syntax.
This is a good starting point because Lisp dialects tend to
have among the simplest lexical and syntactic grammars.
The language does not need to be complete enough for practical usage,
but it should reflect the core syntactic concepts that Lisps share.

\section{Grammar}
We will not define the complete and formal lexical or syntactic grammar of the language,
because most of that information would only be valuable for a parser,
or for a lexer with the goal of producing tokens that can be easily parsed.
Instead, we will define the types of tokens we have to deal with
and only build up an intuitive understanding of how the language works
based on the Lisp-like languages already out there,
because intuition is also what we need decide how a `good' formatting style looks.

The following ABNF specification outlines the primitives that may occur in the source code.
As stated earlier, this is not a full lexical grammar ---
there is no lexing goal nonterminal and whitespace is not accounted for.

\begin{minted}{text}
identifier  = ALPHA *(ALPHA / DIGIT)
keyword     = "quote" / "lambda" / "defun" / "let" / "if" / "and" / "or"
prefix      = "'" / "&"
operator    = "=" / "+" / "-" / "*" / "/"
boolLiteral = "true" / "false"
numLiteral  = 1*DIGIT
leftParen   = "("
rightParen  = ")"
\end{minted}

We could, of course, conceive lots of additional keywords, operators,
types of literals, prefixes and other tokens,
but not many of them would be interesting with regard to code formatting,
because they would be treated like some other token that we already have in our list.

\section{Desired code format}
These tokens are for example sufficient to build the factorial algorithm
from the Lisp programming language Wikipedia page:
\begin{minted}{lisp}
  (defun factorial (n)
    (if (= n 0) 1
        (* n (factorial (- n 1)))))
\end{minted}

We would consider this code example well-formatted ---
the spacing is consistent,
nested expressions are indented and
line breaks are used to split up the top-level expression
that would otherwise be too long to comprehend it quickly.

One might also notice that there are no inherent differences in formatting
between identifiers, keywords, operators and literals.
This is somewhat consistent with their treatment in code,
where they are all conceptually just elements of a list that is denoted by an
S-expression and they can often be used interchangably.
This realization of course further simplifies the formatting of an already simple language.
We will refer to those tokens as \textit{atoms} in the following,
a term that has a to some extent similar meaning in the theory of Lisp.

\section{A simple algorithm}
Now we can come up with an algorithm that operates on a stream of tokens
mostly by just going through them left to right,
does some processing that takes into account the four primary formatting concerns and
prints out the code in a format similar to that of the code example shown above.

\subsection{Spacing}
For our Lisp-like syntax, we want to separate most tokens with a space, with the following exceptions:
\begin{itemize}
  \item No space after a \code{leftParen},
  \item no space before a \code{rightParen} and
  \item no space after a \code{prefix}, which is not visible in the example.
\end{itemize}

To achieve this, all we need to do is define for each type of token
whether it allows a leading space and whether it allows a trailing space.
Then, we can look up between every two tokens
whether the token on the left allows a trailing space and
whether the token on the right allows a leading space and
insert a space only if both do.
Applying this procedure on the tokens
\begin{minted}{text}
  (, a, (, ', b, c, ), )
\end{minted}
results in the code output:
\begin{minted}{lisp}
  (a ('b c))
\end{minted}

It also works for a prefix preceding a list:
\begin{minted}{text}
  (, a, ', (, b, c, ), )
\end{minted}
is printed as:
\begin{minted}{lisp}
  (a '(b c))
\end{minted}

\subsection{Indentation}
\subsection{Hard line breaks}
\subsection{Soft line breaks}

\section{Extensions}

% TODO comments?

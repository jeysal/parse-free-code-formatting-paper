% TODO split this file
\chapter{Lisp-like syntax}
To gain insight on how a non-parsing formatter could be built,
let us first take a look at a small language with Lisp-like syntax.
This is a good starting point because Lisp dialects tend to
have among the simplest lexical and syntactic grammars.
The language does not need to be complete enough for practical usage,
but it should reflect the core syntactic concepts that Lisps share.

\section{Grammar}
We will not define the complete and formal lexical or syntactic grammar of the language,
because most of that information would only be valuable for a parser,
or for a lexer with the goal of producing tokens that can be easily parsed.
Instead, we will define the types of tokens we have to deal with
and only build up an intuitive understanding of how the language works
based on the Lisp-like languages already out there,
because intuition is also what we need decide how a `good' formatting style looks.

The following ABNF specification outlines the primitives that may occur in the source code.
As stated earlier, this is not a full lexical grammar ---
there is no lexing goal nonterminal and whitespace is not accounted for.

\begin{minted}{text}
identifier  = ALPHA *(ALPHA / DIGIT)
keyword     = "quote" / "lambda" / "defun" / "let"
keyword     =/ "if" / "and" / "or"
prefix      = "'" / "&"
operator    = "=" / "+" / "-" / "*" / "/"
boolLiteral = "true" / "false"
numLiteral  = 1*DIGIT
leftParen   = "("
rightParen  = ")"
\end{minted}

We could, of course, conceive lots of additional keywords, operators,
types of literals, prefixes and other tokens,
but not many of them would be interesting with regard to code formatting,
because they would be treated like some other token that we already have in our list.

\section{Desired code format}
These tokens are for example sufficient to build the factorial algorithm
from the Lisp programming language Wikipedia page:
\input{content/lisp-like/factorial-example.tex}

We would consider this code example well-formatted ---
the spacing is consistent,
nested expressions are indented and
line breaks are used to split up the top-level expression
that would otherwise be too long to comprehend it quickly.

One might also notice that there are no inherent differences in formatting
between identifiers, keywords, operators and literals.
This is somewhat consistent with their treatment in code,
where they are all conceptually just elements of a list that is denoted by an
S-expression and they can often be used interchangably.
This realization of course further simplifies the formatting of an already simple language.

\section{A simple algorithm}
Now we can come up with an algorithm that operates on a stream of tokens
mostly by just going through them left to right,
does some processing that takes into account the four primary formatting concerns and
prints out the code in a format similar to that of the code example shown above.

\subsection{Spacing}
For our Lisp-like syntax, we want to separate most tokens with a space, with the following exceptions:
\begin{itemize}
  \item No space after a \code{leftParen},
  \item no space before a \code{rightParen} and
  \item no space after a \code{prefix}, which is not visible in the example.
\end{itemize}

To achieve this, all we need to do is define for each type of token
whether it allows a leading space and whether it allows a trailing space.
Then, we can look up between every two tokens
whether the token on the left allows a trailing space and
whether the token on the right allows a leading space and
insert a space only if both do.
Applying this procedure on the tokens
\begin{minted}{text}
  (, a, (, ', b, c, ), )
\end{minted}
results in the code output:
\begin{minted}{lisp}
  (a ('b c))
\end{minted}

It also works for a prefix preceding a list:
\begin{minted}{text}
  (, a, ', (, b, c, ), )
\end{minted}
is printed as:
\begin{minted}{lisp}
  (a '(b c))
\end{minted}

\subsection{Indentation}
To achieve an indentation similar to that of given example,
we can keep track of the level of nested parentheses surrounding us using a counter.
That counter is initialized with 0,
incremented by 1 after we pass a \code{leftPar} and
decremented by 1 before we pass a \code{rightPar}.
After a line break is placed, we can determine the size of the whitespace we need to print
by looking at the current state of the counter \textit{n}.
We print \textit{n} tabs if our type of indentation is tabs,
or \textit{n * m} spaces if our type of indentation is spaces,
\textit{m} being a positive integer denoting how large our indentation steps should be.
In the code examples shown here, we indent with two spaces each.

We have not yet introduced a mechanism for inserting line breaks between tokens
so everything would be printed in a single line and there is nothing to indent yet,
but for visualization purposes we will assume that line breaks will be placed
some particular spots and represent them as special hard break tokens.

If we use the counter method to generate indentation for the tokens
\begin{minted}{text}
  (, avg, num1, <HARDBREAK>,
  (, add, num2, <HARDBREAK>,
  num3, ), <HARDBREAK>,
  num4, )
\end{minted}
, we get the printed result:
\begin{minted}{lisp}
  (avg num1
    (add num2
      num3)
    num4)
\end{minted}
This is an acceptable format, the indentation and dedentation make it
quite easy to see which expression each identifier belongs to.
It also saves a lot of space by never indenting more than required by the level of expression nesting,
so we will not have to split up lines too often when dealing with the soft line breaking aspect.

It is, however, not exactly the same formatting style that we see in the `factorial' example.
Using our method, we would get the following code for the factorial function,
again assuming that the line breaks remain the same:
\begin{minted}{lisp}
  (defun factorial (n)
    (if (= n 0) 1
      (* n (factorial (- n 1)))))
\end{minted}
Comparing this to the original factorial example code
\input{content/lisp-like/factorial-example.tex}
, we notice that while the first two lines are indented in the same way that we managed to reproduce,
but the last line is indented by six spaces instead of four.
Here, another indentation method is applied,
one that aligns the start of the second and all following elements of a list
by setting the indentation of the third and all following elements
to the column where the second element was printed.
This results in deeper indenting that takes up more space,
but might be considered more readable by some.
Unlike the example code, we will have to choose one of the two styles of indenting,
but we can alternatively produce the latter `aligning' style as well and will do so later in the chapter.

Finally, let us briefly clarify why we need to decrement the counter \textit{before} a \code{rightPar},
although we increment it \textit{after} a \code{leftPar}.
This is only relevant when there is a line break right before a \code{rightPar}.
Consider the following code:
\begin{minted}{lisp}
  (add someLargeIdentifier someVeryLargeIdentifier)
\end{minted}
If our line length is limited to 25 characters,
the only way to print the code without violating the limit is
\begin{minted}{lisp}
  ; line size 25
  (add someLargeIdentifier
    someVeryLargeIdentifier
  )
\end{minted}
, putting the \code{rightPar} on a new line
because it would be one character too much
to appear immediately after \code{someVeryLargeIdentifier}.
If this happens, we want the \code{rightPar} to be aligned with the corresponding \code{leftPar}.
Not doing this would look particularly weird if there are deeper nested expressions,
since the outer \code{rightPar} would appear as if it belonged to the inner \code{leftPar}:
\begin{minted}{lisp}
  ; line size 30
  (add someLargeIdentifier
    (sub someNestedIdentifier
      someOtherNestedIdentifier)
    )
\end{minted}

\subsection{Hard line breaks}
The only source code position where we always want to break
is after the completion of a top-level expression.
We can use the same counter we introduced for indentation for this purpose as well
by inserting a hard line break after a \code{rightPar} token if and only if
the counter has been decremented to 0.
This way, the tokens
\begin{minted}{text}
  (, define, x, (, +, 1, 2, ), ), (, display, x, )
\end{minted}
will be printed as
\begin{minted}{scheme}
  (define x (+ 1 2))
  (display x)
\end{minted}
, with hard breaks inserted after the second and third \code{rightPar}, but not the first.

We can also use hard line breaks to preserve empty lines
that may have been present in the original source code.
This feature has already been mentioned in the introduction and
is usually indispensable for any practical formatter,
because developers will need those empty lines in their code to structure it clearly.
However, this does require changes to the lexer,
so it can already insert hard line break tokens into the token stream
whereever it finds a line that does not contain any token.
Our counter-based hard break insertion will also need to take into account
that it might find hard breaks already present in the token stream
and must not insert another one if the \code{rightPar} is already followed by one,
otherwise we might end up printing more than one consecutive empty line.

\subsection{Soft line breaks}
As mentioned before, the placement of soft line breaks is the most complicated aspect,
but also a well-explored one, with many good algorithms already developed and in use.
Most of those are also quite efficient as far as time and space complexity are concerned,
usually requiring asymptotically linear resources as the number of tokens in a line grows.

\paragraph{Established algorithms}
We could, for example, use the algorithm proposed by Bagge \& Hasu.
\autocite[Chapter: Line Breaking]{prettyGoodFormattingPipeline}
For our Lisp-like language, we would be able to provide the necessary control tokens
`nesting start' and `nesting end' without any parsing, simply by looking at the parentheses
--- other languages might for example have `overloaded' tokens that complicate the matter
and may require parsing to generate useful control tokens.

It is important to keep in mind soft lines breaks will usually be the computationally
most expensive aspect and are thus likely to be a critical path that affects performance the most.
The other concerns usually do not require us to look at more than two tokens at once
or go to a previous token in the stream at any time.
There is not necessarily a hard border between contextual token processing and parsing;
if our processing becomes increasingly complex because the language we want to format
has a complex grammar or our line breaking algorithm requires extensive meta information,
we might already be \textit{parsing} a simplified version of the syntactical grammar.

For all of the strategies to achieve desirable soft line breaking behavior
that were given in the introductory paragraphs on soft line breaks,
we can come up with efficient approximations or exact algorithms.
An algorithm like the one Bagge \& Hasu have developed can be used for breaking at positions
that would be high in a syntax tree constructed by parsing the tokens.
An algorithm like Oppen's \autocite{prettyprinting} and its derivates
can be used for placing breaks so that parameter lists
and other tokens that belong together form groups ---
given that the language is simple enough
so we can infer the necessary information without parsing.

\paragraph{Greedy line-filling}
Another one of the strategies, breaking as late as possible,
is trivial to achieve and requires no more than one pass through the tokens in the line.
In general, however, it does not print very well readable code.
The indentation rules we have already established will take care of inserting
the correct number of spaces or tabs whenever we insert a break.
We keep track of the already printed line length by initializing it with the
number of columns already filled out by the indentation and adding the number
of characters in any token we print to it.
We only print a token if it would not increase our column counter beyond
the maximum allowed line length.
Otherwise, we insert a line break and reset the counter, indenting as usual.
Then we proceed with the remaining tokens until the next hard break.

We also need to carefully consider the interaction with the other printing concerns.
If we break between two tokens that were separated by a space,
the line break must \textit{replace} that space.
We can neither print the space before the line break, producing a line with a trailing space,
nor can we print it after the line break, increasing the indentation of the new line
beyond the indentation generated from our nesting counter.
Concerning indentation, we must additionally take into account that \code{rightPar}s
may be printed as the first token after a soft line break,
and that we defined those to decrease the indentation level \textit{before} being printed.
This means we must process not only the \textit{after}-effect on indentation of the previous token,
but also the \textit{before}-effect of the following token \textit{before}
printing the indentation whitespace that a new line after a soft break requires.

This approach will ensure that too many tokens between two hard breaks will be spread
across multiple lines, and it may do so in a reasonable way,
for example when printing the following tokens with line size 25:
\begin{minted}{text}
  (, let, something, ), (, identifier, 012345,
  43210, (, someIdentifier, 0123456, 789, ), )
\end{minted}
The resulting code with our standard indentation, spacing and hard breaking method
and this greedy line-filling algorithm for soft breaks is:
\begin{minted}{lisp}
  ; line size 25
  (let something)
  (identifier 012345 43210
    (someIdentifier 0123456
      789))
\end{minted}

While this may seem like reasonable formatting style,
it is really just a lucky token arrangement and line length.
If we increase the line length by 1, the code we produce looks weird:
\begin{minted}{lisp}
  ; line size 26
  (let something)
  (identifier 012345 43210 (
      someIdentifier 0123456
      789))
\end{minted}
If we keep the line length but replace \code{identifier}
with \code{something}, something similar happens:
\begin{minted}{lisp}
  ; line size 25
  (let something)
  (something 012345 43210 (
      someIdentifier
      0123456 789))
\end{minted}

\subparagraph{Avoiding undesired separation}
The most annoying issue about both of the `weird' code formats we produced is that
\code{someIdentifier} is separated from its preceding \code{leftPar} by a line break,
especially because the same thing is not applied to the code snippets
\code{(identifier} or \code{(something} that occur earlier and have the same structure.
We want to avoid the separation of token sequences like \code{(x}
and its counterpart \code{y)}, including the case where multiple subsequent
parentheses occur: \code{((x} or \code{y))}.
We also want to avoid a similar separation issue if a break
is inserted immediately after a prefix token,
so constructs like \code{&x} always remain together.
The latter would not only look terrible, it may also be forbidden by some languages
with special treatment of prefixes.

We notice that for the language we are dealing with,
the token pairs that must not be separated by line breaks
are exactly those token pairs that do not allow the insertion of a space between them.
Because of this, we can base a system of line break allowance on our established spacing rules,
effectively treating tokens that are printed with no space inbetween them as single tokens.

This makes the two problematic examples more bearable
and in this case even uniform among one another
as well as consistent with the unproblematic example:
\begin{minted}{lisp}
  ; line size 26
  (let something)
  (identifier 012345 43210
    (someIdentifier 0123456
      789))

  ; line size 25
  (let something)
  (something 012345 43210
    (someIdentifier 0123456
      789))
\end{minted}

\subparagraph{Inevitable length limit violation}
Excessive expression nesting leading to deep indentation
that consumes most of the available columns
or simply the occurence of overly large tokens
can force us to violate the restrictions on maximum line length.
There is no way to place soft line breaks so
the following code does not exceed the line length limit,
including breaking at every single possible position,
even if we ignore the separation avoidance we just introduced:
\begin{minted}{lisp}
  ; limit -|
  (
    abc
    (
      def
      (
        ghi
        (
          jkl
        )
      )
    )
  )
\end{minted}
We could limit the width of indentation that we print to make this problem less likely to occur.
But we cannot entirely eliminate the problem this way ---
if we have to print a large token, the line length may still be exceeded,
even without extraordinarily deep indentation:
\begin{minted}{lisp}
  ; limit 25 -------------|
  (
    abc
    (
      someVeryLargeIdentifier
    )
  )
\end{minted}

To mitigate the effect of such a violation and still
print the remainder of the tokens in a reasonable way,
we bump the maximum line length up to match
the overhang we had to use for the offending token
until the next hard line break.
The following example is once again printed with our regular algorithm,
including separation avoidance.
\begin{minted}{lisp}
  ; limit 15 ---|
  (abc 12345
    12345
    largeIdentifier
    0123456 0123456
    0123456
    0123456)
\end{minted}
The second \code{12345} does not fit into the same line anymore and is placed on a new line instead.
\code{largeIdentifier} does not fit into that line, so it is placed on a new line as well.
However, even on that new line,
the token takes up too much horizontal space, overhanging by 2 characters.
We have no choice but to print it like that and to temporarily bump our line length to 17.
Because of the increased line length, the following line can hold two \code{0123456} tokens,
which would otherwise have been printed on separate lines.
The final two \code{0123456}s cannot be printed on one line,
because we cannot separate the latter one from its closing \code{rightPar},
which in turn cannot be printed on the same line because it would occupy column 18,
exceeding even our increased line length.

Retrospectively, we could have also printed both \code{12345}s on the same line,
because our line length for this part of the code ended up being 17 instead of 15,
but extending the algorithm to do this would require giving up the linear processing order
and going back to a token we have already printed.

% TODO
% simple algs (just break it up in the middle, then at 1/4 + 3/4, etc, see intro:softLineBreaks)

\section{Extensions}

% TODO indentation: aligning style
% TODO comments
% TODO full example?
% TODO full commonlisp/scheme?

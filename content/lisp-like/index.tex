\chapter{Lisp-like syntax}
To gain insight on how a non-parsing formatter could be built,
let us first take a look at a small language with Lisp-like syntax.
This is a good starting point because Lisp dialects tend to
have among the simplest lexical and syntactic grammars.
The language does not need to be complete enough for practical usage,
but it should reflect the core syntactic concepts that Lisps share.

\section{Grammar}
We will not define the complete and formal lexical or syntactic grammar of the language,
because most of that information would only be valuable for a parser,
or for a lexer with the goal of producing tokens that can be easily parsed.
Instead, we will define the types of tokens we have to deal with
and only build up an intuitive understanding of how the language works
based on the Lisp-like languages already out there,
because intuition is also what we need decide how a `good' formatting style looks.

The following ABNF specification outlines the primitives that may occur in the source code.
As stated earlier, this is not a full lexical grammar ---
there is no lexing goal nonterminal and whitespace is not accounted for.

\begin{minted}{text}
identifier  = ALPHA *(ALPHA / DIGIT)
keyword     = "quote" / "lambda" / "defun" / "let"
keyword     =/ "if" / "and" / "or"
prefix      = "'" / "&"
operator    = "=" / "+" / "-" / "*" / "/"
boolLiteral = "true" / "false"
numLiteral  = 1*DIGIT
leftParen   = "("
rightParen  = ")"
\end{minted}

We could, of course, conceive lots of additional keywords, operators,
types of literals, prefixes and other tokens,
but not many of them would be interesting with regard to code formatting,
because they would be treated like some other token that we already have in our list.

\section{Desired code format}
These tokens are for example sufficient to build the factorial algorithm
from the Lisp programming language Wikipedia page:
\input{content/lisp-like/factorial-example.tex}

We would consider this code example well-formatted ---
the spacing is consistent,
nested expressions are indented and
line breaks are used to split up the top-level expression
that would otherwise be too long to comprehend it quickly.

One might also notice that there are no inherent differences in formatting
between identifiers, keywords, operators and literals.
This is somewhat consistent with their treatment in code,
where they are all conceptually just elements of a list that is denoted by an
S-expression and they can often be used interchangably.
This realization of course further simplifies the formatting of an already simple language.
We will refer to those tokens as \textit{atoms} in the following,
a term that has a to some extent similar meaning in the theory of Lisp.

\section{A simple algorithm}
Now we can come up with an algorithm that operates on a stream of tokens
mostly by just going through them left to right,
does some processing that takes into account the four primary formatting concerns and
prints out the code in a format similar to that of the code example shown above.

\subsection{Spacing}
For our Lisp-like syntax, we want to separate most tokens with a space, with the following exceptions:
\begin{itemize}
  \item No space after a \code{leftParen},
  \item no space before a \code{rightParen} and
  \item no space after a \code{prefix}, which is not visible in the example.
\end{itemize}

To achieve this, all we need to do is define for each type of token
whether it allows a leading space and whether it allows a trailing space.
Then, we can look up between every two tokens
whether the token on the left allows a trailing space and
whether the token on the right allows a leading space and
insert a space only if both do.
Applying this procedure on the tokens
\begin{minted}{text}
  (, a, (, ', b, c, ), )
\end{minted}
results in the code output:
\begin{minted}{lisp}
  (a ('b c))
\end{minted}

It also works for a prefix preceding a list:
\begin{minted}{text}
  (, a, ', (, b, c, ), )
\end{minted}
is printed as:
\begin{minted}{lisp}
  (a '(b c))
\end{minted}

\subsection{Indentation}
To achieve an indentation similar to that of given example,
we can keep track of the level of nested parentheses surrounding us using a counter.
That counter is initialized with 0,
incremented by 1 after we pass a \code{leftPar} and
decremented by 1 before we pass a \code{rightPar}.
After a line break is placed, we can determine the size of the whitespace we need to print
by looking at the current state of the counter \textit{n}.
We print \textit{n} tabs if our type of indentation is tabs,
or \textit{n * m} spaces if our type of indentation is spaces,
\textit{m} being a positive integer denoting how large our indentation steps should be.
In the code examples shown here, we indent with two spaces each.

We have not yet introduced a mechanism for inserting line breaks between tokens
so everything would be printed in a single line and there is nothing to indent yet,
but for visualization purposes we will assume that line breaks will be placed
some particular spots and represent them as special hard break tokens.

If we use the counter method to generate indentation for the tokens
\begin{minted}{text}
  (, avg, num1, <HARDBREAK>,
  (, add, num2, <HARDBREAK>,
  num3, ), <HARDBREAK>,
  num4, )
\end{minted}
, we get the printed result:
\begin{minted}{lisp}
  (avg num1
    (add num2
      num3)
    num4)
\end{minted}
This is an acceptable format, the indentation and dedentation make it
quite easy to see which expression each atom belong to.
It also saves a lot of space by never indenting more than required by the level of expression nesting,
so we will not have to split up lines too often when dealing with the soft line breaking aspect.

It is, however, not exactly the same formatting style that we see in the `factorial' example.
Using our method, we would get the following code for the factorial function,
again assuming that the line breaks remain the same:
\begin{minted}{lisp}
  (defun factorial (n)
    (if (= n 0) 1
      (* n (factorial (- n 1)))))
\end{minted}
Comparing this to the original factorial example code
\input{content/lisp-like/factorial-example.tex}
, we notice that while the first two lines are indented in the same way that we managed to reproduce,
but the last line is indented by six spaces instead of four.
Here, another indentation method is applied,
one that aligns the start of the second and all following elements of a list
by setting the indentation of the third and all following elements
to the column where the second element was printed.
This results in deeper indenting that takes up more space,
but might be considered more readable by some.
Unlike the example code, we will have to choose one of the two styles of indenting,
but we can alternatively produce the latter `aligning' style as well and will do so later in the chapter.

Finally, let us briefly clarify why we need to decrement the counter \textit{before} a \code{rightPar},
although we increment it \textit{after} a \code{leftPar}.
This is only relevant when there is a line break right before a \code{rightPar}.
Consider the following code:
\begin{minted}{lisp}
  (add someLargeIdentifier someVeryLargeIdentifier)
\end{minted}
If our line length is limited to 25 characters,
the only way to print the code without violating the limit is
\begin{minted}{lisp}
  ; line size 25
  (add someLargeIdentifier
    someVeryLargeIdentifier
  )
\end{minted}
, putting the \code{rightPar} on a new line
because it would be one character too much
to appear immediately after \code{someVeryLargeIdentifier}.
If this happens, we want the \code{rightPar} to be aligned with the corresponding \code{leftPar}.
Not doing this would look particularly weird if there are deeper nested expressions,
since the outer \code{rightPar} would appear as if it belonged to the inner \code{leftPar}:
\begin{minted}{lisp}
  ; line size 30
  (add someLargeIdentifier
    (sub someNestedIdentifier
      someOtherNestedIdentifier)
    )
\end{minted}

\subsection{Hard line breaks}
The only source code position where we always want to break
is after the completion of a top-level expression.
We can use the same counter we introduced for indentation for this purpose as well
by inserting a hard line break after a \code{rightPar} token if and only if
the counter has been decremented to 0.
This way, the tokens
\begin{minted}{text}
  (, define, x, (, +, 1, 2, ), ), (, display, x, )
\end{minted}
will be printed as
\begin{minted}{scheme}
  (define x (+ 1 2))
  (display x)
\end{minted}
, with hard breaks inserted after the second and third \code{rightPar}, but not the first.

We can also use hard line breaks to preserve empty lines
that may have been present in the original source code.
This feature has already been mentioned in the introduction and
is usually indispensable for any practical formatter,
because developers will need those empty lines in their code to structure it clearly.
However, this does require changes to the lexer,
so it can already insert hard line break tokens into the token stream
whereever it finds a line that does not contain any token.
Our counter-based hard break insertion will also need to take into account
that it might find hard breaks already present in the token stream
and must not insert another one if the \code{rightPar} is already followed by one,
otherwise we might end up printing more than one consecutive empty line.

\subsection{Soft line breaks}
As mentioned before, the placement of soft line breaks is the most complicated aspect,
but also a well-explored one, with many good algorithms already developed and in use.
Most of those are also quite efficient as far as time and space complexity are concerned,
usually requiring asymptotically linear resources as the number of tokens in a line grows.

We could, for example, use the algorithm proposed by Bagge \& Hasu.
\autocite[Chapter: Line Breaking]{prettyGoodFormattingPipeline}
For our Lisp-like language, we would be able to provide the necessary control tokens
`nesting start' and `nesting end' without any parsing, simply by looking at the parentheses
--- other languages might for example have `overloaded' tokens that complicate the matter
and may require parsing to generate useful control tokens.

It is important to keep in mind soft lines breaks will usually be the computationally
most expensive aspect and are thus likely to be a critical path that affects performance the most.
The other concerns usually do not require us to look at more than two tokens at once
or go to a previous token in the stream at any time.
There is not necessarily a hard border between contextual token processing and parsing;
if our processing becomes increasingly complex because the language we want to format
has a complex grammar or our line breaking algorithm requires extensive meta information,
we might already be \textit{parsing} a simplified version of the syntactical grammar.

For all of the strategies to achieve desirable soft line breaking behavior
that were given in the introductory paragraphs on soft line breaks,
we can come up with efficient approximations or exact algorithms.
An algorithm like the one Bagge \& Hasu have developed can be used for breaking at positions
that would be high in a syntax tree constructed by parsing the tokens.
An algorithm like Oppen's \autocite{prettyprinting} and its derivates
can be used for placing breaks so that parameter lists
and other tokens that belong together form groups ---
given that the language is simple enough
so we can infer the necessary information without parsing.

TODO
simple algs (just break it up in the middle, then at 1/4 + 3/4, etc, see intro:softLineBreaks)

\section{Extensions}

% TODO indentation: aligning style
% TODO comments
% TODO full example?
% TODO full commonlisp/scheme?

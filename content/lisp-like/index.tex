\chapter{Lisp-like syntax}
To gain insight on how a non-parsing formatter could be built,
let us first take a look at a small language with Lisp-like syntax.
This is a good starting point because Lisp dialects tend to
have among the simplest lexical and syntactic grammars.
The language does not need to be complete enough for practical usage,
but it should reflect the core syntactic concepts that Lisps share.

\section{Grammar}
We will not define the complete and formal lexical or syntactic grammar of the language,
because most of that information would only be valuable for a parser,
or for a lexer with the goal of producing tokens that can be easily parsed.
Instead, we will define the types of tokens we have to deal with
and only build up an intuitive understanding of how the language works
based on the Lisp-like languages already out there,
because intuition is also what we need decide how a `good' formatting style looks.

The following ABNF specification outlines the primitives that may occur in the source code.
As stated earlier, this is not a full lexical grammar ---
there is no lexing goal nonterminal and whitespace is not accounted for.

\begin{minted}{text}
identifier  = ALPHA *(ALPHA / DIGIT)
keyword     = "quote" / "lambda" / "defun" / "let" / "if" / "and" / "or"
prefix      = "'" / "&"
operator    = "=" / "+" / "-" / "*" / "/"
boolLiteral = "true" / "false"
numLiteral  = 1*DIGIT
leftParen   = "("
rightParen  = ")"
\end{minted}

We could, of course, conceive lots of additional keywords, operators,
types of literals, prefixes and other tokens,
but not many of them would be interesting with regard to code formatting,
because they would be treated like some other token that we already have in our list.

\section{Desired code format}
\section{A simple algorithm}

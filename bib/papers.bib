@inbook{prettyGoodFormattingPipeline,
  author="Bagge, Anya Helene
  and Hasu, Tero",
  editor="Erwig, Martin
  and Paige, Richard F.
  and Van Wyk, Eric",
  title="A Pretty Good Formatting Pipeline",
  bookTitle="Software Language Engineering: 6th International Conference, SLE 2013, Indianapolis, IN, USA, October 26-28, 2013. Proceedings",
  year="2013",
  publisher="Springer International Publishing",
  address="Cham",
  pages="177--196",
  abstract="Proper formatting makes the structure of a program apparent and aids program comprehension. The need to format code arises in code generation and transformation, as well as in normal reading and editing situations. Commonly used pretty-printing tools in transformation frameworks provide an easy way to produce indented code that is fairly readable for humans, without reaching the level of purpose-built reformatting tools, such as those built into IDEs. This paper presents a library of pluggable components, built to support style-based formatting and reformatting of code, and to enable further experimentation with code formatting.",
  isbn="978-3-319-02654-1",
  doi="10.1007/978-3-319-02654-1_10",
  %url="https://doi.org/10.1007/978-3-319-02654-1_10",
}
@Inbook{designPrettyPrintingLib,
  author="Hughes, John",
  editor="Jeuring, Johan
  and Meijer, Erik",
  title="The design of a pretty-printing library",
  bookTitle="Advanced Functional Programming: First International Spring School on Advanced Functional Programming Techniques B{\aa}stad, Sweden, May 24--30, 1995 Tutorial Text",
  year="1995",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="53--96",
  abstract="In this chapter we have considered the design of combinator libraries. We saw how studying the algebraic properties of the combinators desired can both help to suggest natural choices of representation, and guide the implementation of the operators. We saw several examples --- lists, monads, and a pretty-printing library. For this kind of program development we need a language with higher-order functions and lazy evaluation, for which equational reasoning is valid; in other words, Haskell is ideally suited.",
  isbn="978-3-540-49270-2",
  doi="10.1007/3-540-59451-5_3",
  %url="https://doi.org/10.1007/3-540-59451-5_3"
}
@inproceedings{prettierPrinter,
  author = {Philip Wadler},
  title = {A Prettier Printer},
  booktitle = {Journal of Functional Programming},
  year = {1998},
  pages = {223--244},
  publisher = {Palgrave Macmillan},
}
@article{prettyprinting,
  author = {Oppen, Derek C.},
  title = {Prettyprinting},
  journal = {ACM Trans. Program. Lang. Syst.},
  issue_date = {Oct. 1980},
  volume = {2},
  number = {4},
  month = 10,
  year = {1980},
  issn = {0164-0925},
  pages = {465--483},
  numpages = {19},
  %url = {http://doi.acm.org/10.1145/357114.357115},
  doi = {10.1145/357114.357115},
  acmid = {357115},
  publisher = {ACM},
  address = {New York, NY, USA},
}
@article{syntaxDirectedPrettyprinting,
  author={L. F. Rubin},
  journal={IEEE Transactions on Software Engineering},
  title={Syntax-Directed Pretty Printing --- A First Step Towards a Syntax-Directed Editor},
  year={1983},
  volume={SE-9},
  number={2},
  pages={119-127},
  keywords={Editor generator;formatter;language-independence;pretty printer;programming environments;syntax-directed editor;Computer languages;Printers;Programming environments;Software engineering;Software tools;Switches;Editor generator;formatter;language-independence;pretty printer;programming environments;syntax-directed editor},
  doi={10.1109/TSE.1983.236456},
  ISSN={0098-5589},
  month={03},
}
@article{onePassPrettyprinter,
  author = {Hearn, Anthony C. and Norman, Arthur C.},
  title = {A One-pass Prettyprinter},
  journal = {SIGPLAN Not.},
  issue_date = {December 1979},
  volume = {14},
  number = {12},
  month = 12,
  year = {1979},
  issn = {0362-1340},
  pages = {50--58},
  numpages = {9},
  url = {http://doi.acm.org/10.1145/954004.954005},
  doi = {10.1145/954004.954005},
  acmid = {954005},
  publisher = {ACM},
  address = {New York, NY, USA},
}
@inproceedings{parsingAndReflectivePrinting,
 author = {Zhu, Zirun and Zhang, Yongzhe and Ko, Hsiang-Shang and Martins, Pedro and Saraiva, Jo\~{a}o and Hu, Zhenjiang},
 title = {Parsing and Reflective Printing, Bidirectionally},
 booktitle = {Proceedings of the 2016 ACM SIGPLAN International Conference on Software Language Engineering},
 series = {SLE 2016},
 year = {2016},
 isbn = {978-1-4503-4447-0},
 location = {Amsterdam, Netherlands},
 pages = {2--14},
 numpages = {13},
 %url = {http://doi.acm.org/10.1145/2997364.2997369},
 doi = {10.1145/2997364.2997369},
 acmid = {2997369},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {bidirectional transformations, domain-specific languages, parsing, reflective printing},
}
@inproceedings{parsingBroadSense,
  author="Zaytsev, Vadim
  and Bagge, Anya Helene",
  editor="Dingel, Juergen
  and Schulte, Wolfram
  and Ramos, Isidro
  and Abrah{\~a}o, Silvia
  and Insfran, Emilio",
  title="Parsing in a Broad Sense",
  booktitle="Model-Driven Engineering Languages and Systems",
  year="2014",
  publisher="Springer International Publishing",
  address="Cham",
  pages="50--67",
  abstract="Having multiple representations of the same instance is common in software language engineering: models can be visualised as graphs, edited as text, serialised as XML. When mappings between such representations are considered, terms ``parsing'' and ``unparsing'' are often used with incompatible meanings and varying sets of underlying assumptions. We investigate 12 classes of artefacts found in software language processing, present a case study demonstrating their implementations and state-of-the-art mappings among them, and systematically explore the technical research space of bidirectional mappings to build on top of the existing body of work and discover as of yet unused relationships.",
  isbn="978-3-319-11653-2"
}
